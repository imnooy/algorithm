# 수학

(바킹독님의 실전 알고리즘 강의를 통해 공부한 내용)
https://blog.encrypted.gg/

## 소수

### 소수의 정의

**소수**
* 1과 자기 자신으로만 나누어지는 수
* 약수가 2개인 수

<br>

**합성수**
* 1과 자기 자신을 제외한 다른 약수를 가지고 있는 수

(1은 소수도, 합성수도 아니다!)

<br>

### 소수 판정법

**소수**
* 1과 자기 자신으로만 나누어지는 수
* 약수가 2개인 수
* ***2부터 N-1까지의 수로 나누어지지 않는 수***

```java
boolean isPrime(int n) {
  if(n == 1) return 0;
  for(int i = 2; i < n; i++) {
    if(n % i == 0) return 0;
  }
  return 1;
}
```

=> 시간복잡도 : **O(n)**

<br>

### 합성수 N에서 1을 제외한 가장 작은 약수는 √n이하이다.

* 증명
  * 합성수 N에서 1을 제외한 가장 작은 약수를 x라고 하자.
  N/x 또한 1이 아닌 N의 약수이기 때문에 x ≤ (N/x)이다.
  우변의 분모 x를 좌변으로 옮기면 x^2 ≤ N이므로
  ***x ≤ √N*** !!!

### **2부터 ~~N-1~~ √n까지의 수로 나누어지지 않으면 소수이다.

<br>

```java
void isPrime(int n) {
  if(n == 1) return 0;
  for(int i = 2; i * i <= n; i++) {
    if(n % i == 0) return 0;
  }
  return 1;
}
```

=> 시간복잡도 : **O(√N)**

(범위 내에서의 소수 판정법 : 에라토스테네스의 채 참고!!!)

<br>

---

## 소인수분해

### 1100 = 2 * 2 * 5 * 5 * 11

N = 1100 (소인수분해를 할 수) / i = 2 (2로 시작해서 1씩 증가)

1. N이 i로 나누어지는지 확인한다.
2. 나누어진다면 소인수 목록에 i를 추가하고 N을 i로 나눈다.
3. 더 이상 N이 i로 나누어지지 않는다면 i를 1씩 증가시키고 1번부터 반복한다.

<br>

### 방법의 정당성
* 소인수 목록에 적힌 수들을 곱했을 때 N이 되는가? -> **Yes**
* 목록에 있는 수들이 전부 소수인가? -> **Yes**

<br>

### 시간복잡도의 개선
* N이 1일 때 종료하는 대신 i * i > N일 때 종료 -> **O(√n)**

<br>

---

## 최대공약수

