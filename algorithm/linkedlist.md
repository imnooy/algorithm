# 연결 리스트

(바킹독님의 실전 알고리즘 강의를 통해 공부한 내용)
https://blog.encrypted.gg/

### 연결 리스트의 성질
1. k번째 원소를 확인/변경하기 위해 O(k)가 필요하다. 
    + 배열과 다르게 원소가 연속된 공간에 위치하지 않는다.
2. 임의의 위치에 원소를 추가 / 임의의 위치의 원소 제거는 O(1)
3. 원소들이 메모리 상에 연속해 있지 않아 Cache hit rate가 낮지만 할당이 쉽다.

----

### 연결 리스트의 종류
1. 단일 연결 리스트
<img width='300' alt="단일 연결 리스트" src="https://user-images.githubusercontent.com/75800620/112416860-d801a100-8d69-11eb-9feb-d682cba2313b.png">
2. 이중 연결 리스트
<img width='300' alt="이중 연결 리스트" src="https://user-images.githubusercontent.com/75800620/112416966-08e1d600-8d6a-11eb-9bc7-46f96743d7e1.png">
3. 원형 연결 리스트
<img width='300' alt="원형 연결 리스트" src="https://user-images.githubusercontent.com/75800620/112417031-22831d80-8d6a-11eb-8fdb-b039a3fed0e9.png">

----

### 배열 vs 연결 리스트

</br>

둘 다 선형 자료구조!

|     |배열|연결 리스트|
|:---:|:---:|:---:|
|k번째 원소의 접근|O(1)|O(k)|
|임의 위치에 원소 추가/제거|O(N)|O(1)|
|메모리 상의 배치|연속|불연속|
|추가로 필요한 공간</br>(Overhead)|-|O(N)|

----

### 기능과 구현

</br>

원소의 개수는 N개라고 가정하자.

* 임의의 위치에 있는 원소를 확인/변경 - **O(N)**
    + k번째 원소를 확인하려면 k번 이동
    + -> 평균적으로 N/2의 시간이 걸리니 O(N)
* 임의의 위치에 원소를 추가하는 연산 - **O(1)**
    + 배열처럼 전부 원소를 옮길 필요가 없고, 가리키는 주소만 바꾸면 된다.
    + 단, 바꿀 위치의 주소가 정해지지 않은 경우에는 그 위치의 원소까지 찾아기는 O(N)의 시간이 추가로 든다.
* 임의의 위치의 원소를 제거 - **O(1)**
    + 이것도 마찬가지로 가리키는 원소만 다음 원소로 바꾸면 된다.
    + 메모리 누수를 막기 위해 메모리는 해제해 줘야 한다.

</br>

=> 임의의 위치의 원소를 추가하거나 제거할 때 효율적이다.
    